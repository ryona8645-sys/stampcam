<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>StampCam (ドロワー外タップで閉じる/枚数バッジ/コンパクトUI/保存方式切替/黄リング/99 + "-")</title>
<style>
  :root{--sa-b:env(safe-area-inset-bottom,0px);--sa-l:env(safe-area-inset-left,0px);--sa-r:env(safe-area-inset-right,0px)}
  *{box-sizing:border-box}
  body{font-family:sans-serif;margin:10px 10px calc(140px + var(--sa-b));background:#000}
  video{width:100%;max-height:78vh;object-fit:contain;background:#000;border-radius:8px}
  button{padding:10px;border:1px solid #ccc;border-radius:10px;background:#fff;cursor:pointer}

  /* Backdrop for drawers */
  .backdrop{
    position:fixed;inset:0;z-index:25;background:rgba(0,0,0,.3);
    opacity:0;pointer-events:none;transition:opacity .2s ease;
  }
  .backdrop.show{opacity:1;pointer-events:auto}

  /* Bottom dock（コンパクト配置） */
  .dock{
    position:fixed;left:0;right:0;bottom:0;z-index:20;
    background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(20,20,20,.88) 40%);
    display:flex;flex-direction:column;align-items:center;
    padding:6px max(10px,var(--sa-r)) calc(8px + var(--sa-b)) max(10px,var(--sa-l));
    gap:6px;backdrop-filter: blur(4px);color:#eee
  }
  .zoomBar{width:96%;display:flex;align-items:center;gap:8px}
  .zoomBar label{min-width:40px;font-size:12px}
  .zoomBar input[type=range]{flex:1;height:26px}
  .cap-badge{font-size:12px;min-width:48px;text-align:right}

  /* ボタン行：中央に撮影ボタン、左にライト、右に解像度（右端寄せ） */
  .btnRow{
    width:96%;
    display:grid;
    grid-template-columns: 1fr auto minmax(0,1fr);
    align-items:center;
  }
  .leftBtns,.rightBtns{display:flex;gap:8px;align-items:center}
  .rightBtns{justify-content:flex-end;width:100%}
  #resBtn{margin-left:auto}
  .iconBtn{height:40px;padding:0 10px;border-radius:10px;font-size:12px}
  #shootBtn{
    border:none;width:68px;height:68px;border-radius:999px;background:#fff;
    box-shadow:0 2px 10px rgba(0,0,0,.25), inset 0 0 0 4px #e33;font-weight:bold;justify-self:center
  }
  #torchBtn.torch-on{background:#ffc400;border-color:#e6b100}

  /* Side toggles */
  .toggle{
    position:fixed;top:50%;transform:translateY(-50%);z-index:35;
    display:flex;align-items:center;justify-content:center;width:32px;height:88px;border-radius:10px;
    background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.25);
    writing-mode:vertical-rl;text-orientation:mixed;font-size:12px;letter-spacing:.5px;
    user-select:none;-webkit-user-select:none
  }
  .l-toggle{left:4px}
  .r-toggle{right:4px}

  /* Left drawer (controls) */
  .ldrawer{
    position:fixed;top:0;left:0;height:100dvh;width:min(80vw,520px);z-index:30;
    transform:translateX(calc(-100% + 12px));transition:transform .25s ease;
    display:flex;flex-direction:column;background:#111;color:#fff;border-right:1px solid rgba(255,255,255,.1);
    box-shadow:8px 0 20px rgba(0,0,0,.25)
  }
  .ldrawer.open{transform:translateX(0)}
  .ld-header{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px 12px;background:linear-gradient(180deg,#222,#111)}
  .ld-body{padding:12px;display:flex;flex-direction:column;gap:10px;overflow:auto;flex:1}
  .input-row{display:flex;gap:8px;align-items:center}
  .input-row input[type=text]{flex:1;min-width:140px;padding:10px;border:1px solid #666;border-radius:10px;background:#000;color:#fff}
  .legend{font-size:12px;color:#bbb}
  .grid{display:grid;grid-template-columns:repeat(5,1fr);gap:6px}

  /* 押下表示：黄リング／撮影済み：青／枚数バッジ */
  .grid button{
    width:100%;position:relative;transition:transform .05s ease, box-shadow .15s ease, filter .15s ease;
    font-variant-numeric:tabular-nums;padding-right:26px;
  }
  .grid button:active{transform:scale(.97)}
  .grid button.on{ box-shadow:0 0 0 3px #ffd400 inset }
  .grid button.shot{ background:#0a66c2;color:#fff;border-color:#0a66c2 }
  .grid button.shot.on{ box-shadow:0 0 0 3px #ffd400, inset 0 0 0 2px rgba(0,0,0,.12) }
  .grid button.shot.on::after{
    content:"選択中";position:absolute;top:-8px;right:-4px;background:#ffd400;color:#111;
    font-size:10px;line-height:1;padding:2px 6px;border-radius:10px
  }
  .badge{
    position:absolute;top:4px;right:4px;min-width:18px;height:18px;
    background:#ff5722;color:#fff;border-radius:9px;font-size:11px;line-height:18px;
    text-align:center;padding:0 5px;box-shadow:0 1px 4px rgba(0,0,0,.25);display:none;
  }
  .badge.show{display:inline-block}
  .grid button.label-dash{background:#eee}
  .grid button.label-dash.on{box-shadow:0 0 0 3px #ffd400 inset}

  /* Right drawer (preview) */
  .rdrawer{
    position:fixed;top:0;right:0;height:100dvh;width:min(70vw,480px);z-index:30;
    transform:translateX(calc(100% - 12px));transition:transform .25s ease;
    display:flex;flex-direction:column;background:#111;color:#fff;border-left:1px solid rgba(255,255,255,.1);
    box-shadow:-8px 0 20px rgba(0,0,0,.25)
  }
  .rdrawer.open{transform:translateX(0)}
  .rd-header{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px 12px;background:linear-gradient(180deg,#222,#111)}
  .rd-body{flex:1;overflow:hidden;position:relative}
  #lastShot{
    position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(1);
    transform-origin:center center;max-width:100%;max-height:100%;background:#000;border-radius:8px;touch-action:none
  }
  .pinch-hint{
    position:absolute;left:0;right:0;bottom:8px;text-align:center;font-size:12px;color:#eee;
    background:linear-gradient(180deg,transparent,rgba(0,0,0,.55));padding:8px 4px
  }
  .close-btn{background:#333;color:#fff;border:1px solid #666;border-radius:8px;padding:6px 10px;font-size:12px}

  /* Toast */
  .toast{
    position:fixed;left:50%;bottom:calc(160px + var(--sa-b));
    transform:translateX(-50%);padding:10px 14px;border-radius:12px;font-size:14px;color:#fff;z-index:99;
    background:#333;opacity:0;pointer-events:none;transition:opacity .2s ease;
    max-width:90vw;text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.25)
  }
  .toast.show{opacity:.96}
  .toast.ok{background:#2e7d32}
  .toast.err{background:#c62828}
</style>

<div id="wrap">
  <video id="v" autoplay playsinline></video>
</div>

<div class="dock">
  <div class="zoomBar">
    <label for="zoomRange">ズーム</label>
    <input id="zoomRange" type="range" min="1" max="1" step="0.1" value="1" disabled>
    <span id="zoomVal" class="cap-badge">x1.0</span>
  </div>
  <div class="btnRow">
    <div class="leftBtns">
      <button id="torchBtn" class="iconBtn" title="ライト（トーチ）">ライト</button>
    </div>
    <button id="shootBtn" title="撮影">撮影</button>
    <div class="rightBtns">
      <button id="resBtn" class="iconBtn" title="解像度切替">1280×720</button>
    </div>
  </div>
</div>

<!-- Tap tabs -->
<div class="toggle l-toggle" id="lToggle">機器/入力</div>
<div class="toggle r-toggle" id="rToggle">プレビュー</div>

<!-- Backdrop (outside tap to close drawers) -->
<div id="backdrop" class="backdrop" aria-hidden="true"></div>

<!-- Left drawer -->
<aside id="ldrawer" class="ldrawer" aria-label="機器選択とファイル名付加">
  <div class="ld-header">
    <span>コントロール</span>
    <button class="close-btn" id="lClose">閉じる</button>
  </div>
  <div class="ld-body">
    <div class="input-row">
      <input id="suffixInput" type="text" placeholder="ファイル名に付加（例：1F-東, 盤A, ONU周り）">
      <button id="resetMarkBtn" title="撮影済みマークと枚数をリセット">リセット</button>
    </div>
    <div class="legend">選択: 黄リング / 撮影済み: 青 / 右上の丸が撮影枚数 / 「-」はそのままファイル名に</div>
    <div id="nums" class="grid"></div>
  </div>
</aside>

<!-- Right drawer -->
<aside id="rdrawer" class="rdrawer" aria-label="直前の写真プレビュー">
  <div class="rd-header">
    <span>プレビュー</span>
    <button class="close-btn" id="rClose">閉じる</button>
  </div>
  <div class="rd-body">
    <img id="lastShot" alt="直前写真プレビュー" />
    <div class="pinch-hint" id="pinchHint">ピンチ操作で拡大・縮小</div>
  </div>
</aside>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<canvas id="c" style="display:none"></canvas>
<script>
(async()=>{
  const v=document.getElementById('v'),c=document.getElementById('c'),ctx=c.getContext('2d');
  const shootBtn=document.getElementById('shootBtn'),resBtn=document.getElementById('resBtn');
  const ldrawer=document.getElementById('ldrawer'), rdrawer=document.getElementById('rdrawer'), img=document.getElementById('lastShot');
  const nums=document.getElementById('nums'), suffixInput=document.getElementById('suffixInput'), resetMarkBtn=document.getElementById('resetMarkBtn');
  const lToggle=document.getElementById('lToggle'), rToggle=document.getElementById('rToggle');
  const lClose=document.getElementById('lClose'), rClose=document.getElementById('rClose');
  const zoomRange=document.getElementById('zoomRange'), zoomVal=document.getElementById('zoomVal');
  const torchBtn=document.getElementById('torchBtn');
  const pinchHint=document.getElementById('pinchHint');
  const toastEl=document.getElementById('toast');
  const backdrop=document.getElementById('backdrop');

  let stream=null,useHigh=false,currentLabel='',previewUrl=null;

  let leftOpen=false, rightOpen=false;
  let videoTrack=null;
  let torchOn=false;
  resBtn.textContent = (useHigh?'3840×2160':'1280×720');


  /* ==== 保存方式設定 ==== */
  const SAVE_MODE = 'auto'; // 'auto' | 'opfs' | 'picker'

  /* ==== 状態保存（更新してもリセットされない） ==== */
  const STORAGE_KEY = 'stampcam_state_v1';

  function readState(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); }
    catch{ return null; }
  }
  function snapshotState(){
    const countsObj = {};
    try{
      for (const [k,v] of shotCounts.entries()) countsObj[k]=v;
    }catch{}
    const shotLabels = [...nums.children]
      .filter(b=>b.classList.contains('shot'))
      .map(b=>b.dataset.label || b.textContent);
    return {
      v:1,
      useHigh: !!useHigh,
      currentLabel: currentLabel || '',
      suffix: suffixInput.value || '',
      counts: countsObj,
      shotLabels,
      savedAt: Date.now()
    };
  }
  let _saveT=null;
  function saveState(debounceMs=80){
    try{
      clearTimeout(_saveT);
      _saveT=setTimeout(()=>{
        try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshotState())); }catch{}
      }, debounceMs);
    }catch{}
  }

  const __savedState = readState();
  let __restoreLabel = __savedState?.currentLabel || '';
  let __restoreSuffix = __savedState?.suffix || '';
  let __restoreCounts = __savedState?.counts || null;
  let __restoreShotLabels = Array.isArray(__savedState?.shotLabels) ? __savedState.shotLabels : [];
  if (__savedState && typeof __savedState.useHigh === 'boolean') {
    useHigh = __savedState.useHigh;
  }

  /* ---------- Toast ---------- */
  let toastTimer=null;
  function toast(msg,type='ok'){
    toastEl.textContent=msg;
    toastEl.className='toast show '+(type==='err'?'err':'ok');
    clearTimeout(toastTimer);
    toastTimer=setTimeout(()=>{ toastEl.classList.remove('show'); }, 2000);
  }

  /* ---------- 撮影枚数カウンタ ---------- */
  const shotCounts = new Map();
  function getBtnByLabel(label){
    return [...nums.children].find(x=>(x.dataset.label && x.dataset.label===label)||(!x.dataset.label && x.textContent===label));
  }
  function setCount(label, n){
    shotCounts.set(label, n);
    const btn = getBtnByLabel(label);
    if(!btn) return;
    let badge = btn.querySelector('.badge');
    if(!badge){ badge = document.createElement('span'); badge.className='badge'; btn.appendChild(badge); }
    badge.textContent = String(n);
    badge.classList.toggle('show', n>0);
    saveState();
  }
  function incCount(label){
    const cur = shotCounts.get(label) || 0;
    setCount(label, cur+1);
  }
  function resetAllCounts(){
    shotCounts.clear();
    [...nums.children].forEach(btn=>{
      const b = btn.querySelector('.badge'); if(b){ b.textContent='0'; b.classList.remove('show'); }
    });
    saveState();
  }

  /* ---------- Buttons: "-" then 1..99 ---------- */
  const dashBtn=document.createElement('button');
  dashBtn.textContent='-'; dashBtn.classList.add('label-dash'); dashBtn.dataset.label='-';
  dashBtn.onclick=()=>setLabel(dashBtn.dataset.label); nums.appendChild(dashBtn);

  for(let i=1;i<=99;i++){
    const b=document.createElement('button');
    b.textContent='機器'+String(i).padStart(2,'0');
    b.dataset.label='機器'+i;
    b.onclick=()=>setLabel(b.dataset.label);
    nums.appendChild(b);
  }
    [...nums.children].forEach(btn=>setCount(btn.dataset.label||btn.textContent, 0));

  if(__restoreSuffix) suffixInput.value = __restoreSuffix;
  if(__restoreCounts){ for(const [k,v] of Object.entries(__restoreCounts)){ const n=Number(v); if(Number.isFinite(n)) setCount(k,n);} }
  if(__restoreShotLabels){ __restoreShotLabels.forEach(l=>{ const b=getBtnByLabel(l); if(b) b.classList.add('shot'); }); }
  if(__restoreLabel) setLabel(__restoreLabel);
  saveState(0);

function setLabel(label){
    currentLabel=label;
    [...nums.children].forEach(x=>{
      const on=(x.dataset.label===label)||(!x.dataset.label && x.textContent===label);
      x.classList.toggle('on', on);
      x.setAttribute('aria-pressed', on);
    });
    saveState();
  }

  /* ---------- Camera ---------- */
  async function startCamera(){
    stopStream();
    const w=useHigh?3840:1280,h=useHigh?2160:720;
    try{
      stream=await navigator.mediaDevices.getUserMedia({
        video:{facingMode:{ideal:"environment"},width:{ideal:w},height:{ideal:h}},audio:false
      });
      v.srcObject=stream;
      videoTrack=stream.getVideoTracks()[0];
      setupZoomUI(); setupTorchUI();
    }catch(e){ alert('カメラ起動失敗: '+e); }
  }

  function isStreamActive(){
    return stream && stream.getTracks().some(t=>t.readyState==='live');
  }
  async function ensureStreamAlive(){
    if(!isStreamActive() || v.readyState<2){
      await startCamera();
    }
  }

  function setupZoomUI(){
    if(!videoTrack) return;
    const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
    if(caps.zoom){
      const min = caps.zoom.min || 1;
      const max = caps.zoom.max || 1;
      const step = caps.zoom.step || 0.1;
      zoomRange.min=min; zoomRange.max=max; zoomRange.step=step; zoomRange.disabled=false;
      const settings = videoTrack.getSettings ? videoTrack.getSettings() : {};
      const cur = settings.zoom || 1;
      zoomRange.value=cur; zoomVal.textContent='x'+Number(cur).toFixed(1);
    }else{ zoomRange.disabled=true; zoomVal.textContent='x1.0'; }
  }

  async function applyZoom(val){
    if(!videoTrack) return;
    try{ await videoTrack.applyConstraints({advanced:[{zoom:val}]}); }
    catch{ try{ await videoTrack.applyConstraints({zoom:val}); }catch(e){} }
  }

  function setupTorchUI(){
    if(!videoTrack) return;
    const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
    torchBtn.disabled=!caps.torch; if(!caps.torch){ torchBtn.title='端末が非対応です'; }
  }

  async function setTorch(on){
    if(!videoTrack) return;
    try{ await videoTrack.applyConstraints({advanced:[{torch:on}]}); torchOn=on; torchBtn.classList.toggle('torch-on', torchOn); }
    catch(e){ alert('ライト切替に失敗: '+e); }
  }

  zoomRange.addEventListener('input', async (e)=>{ const z=Number(e.target.value); zoomVal.textContent='x'+z.toFixed(1); await applyZoom(z); });
  torchBtn.addEventListener('click', async ()=>{ if(!torchBtn.disabled) await setTorch(!torchOn); });
  resBtn.addEventListener('click', async ()=>{
    useHigh=!useHigh;
    resBtn.textContent=(useHigh?'3840×2160':'1280×720');
    saveState();
    await startCamera();
  });

  /* ---------- Save helper ---------- */
  async function saveBlob(blob, filename){
    if (SAVE_MODE === 'auto'){
      try{
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url; a.download=filename;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url),2000);
        return 'download';
      }catch(e){ throw new Error('自動ダウンロードに失敗: '+e.message); }
    }

    if (SAVE_MODE === 'opfs'){
      if (!(navigator.storage && navigator.storage.getDirectory)) {
        throw new Error('自動保存（OPFS）が未対応のブラウザです');
      }
      try{
        const root = await navigator.storage.getDirectory();
        const handle = await root.getFileHandle(filename, { create:true });
        const w = await handle.createWritable(); await w.write(blob); await w.close();
        return 'opfs';
      }catch(e){ throw new Error('OPFSへの保存に失敗: '+e.message); }
    }

    if (SAVE_MODE === 'picker' && window.showSaveFilePicker && window.isSecureContext){
      try{
        const handle = await showSaveFilePicker({
          suggestedName: filename,
          types:[{description:'JPEG Image', accept:{'image/jpeg':['.jpg','.jpeg']}}]
        });
        const w=await handle.createWritable(); await w.write(blob); await w.close();
        return 'fs';
      }catch(e){
        if (e && (e.name==='AbortError' || e.code===20)) throw new Error('保存をキャンセルしました');
        throw new Error('保存に失敗（File Picker）: '+e.message);
      }
    }

    throw new Error('この環境では自動保存手段を提供できません');
  }

  /* ---------- Capture & save ---------- */
  function ts(){const d=new Date(),z=n=>String(n).padStart(2,'0');return`${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`;}
  async function captureFrame(){
    const vw=v.videoWidth,vh=v.videoHeight; if(!vw||!vh) throw new Error('カメラ初期化中です');
    c.width=vw; c.height=vh; ctx.drawImage(v,0,0,vw,vh);
    return new Promise((r,rej)=>c.toBlob(b=>b?r(b):rej(new Error('画像の生成に失敗しました')),'image/jpeg',0.9));
  }

  // プレビュー拡大の状態
  let scale=1,lastScale=1,startDist=0,startX2=0,startY2=0,imgX=0,imgY=0,lastX=0,lastY=0, doubleTapTime=0;
  function resetPreviewTransform(){
    scale=1; lastScale=1; imgX=0; imgY=0; lastX=0; lastY=0;
    updateTransform();
  }

  async function doShoot(){
    const label=(currentLabel||'未指定').trim();
    try{
      const safe=s=>s.replace(/[\\/:*?"<>|]/g,'_');
      const blob=await captureFrame();
      const extra=(suffixInput.value||'').trim();
      const suffix=extra?('_'+safe(extra)):'';
      const filename=safe(`${label}${suffix}_${ts()}.jpg`);

      const how = await saveBlob(blob, filename);

      if(previewUrl) URL.revokeObjectURL(previewUrl);
      previewUrl=URL.createObjectURL(blob); img.src=previewUrl;
      resetPreviewTransform();

      if(label && label!=='未指定'){
        const btn=getBtnByLabel(label);
        if(btn){ btn.classList.add('shot'); }
        incCount(label);
      }

      if (how==='opfs' || how==='fs') {
        toast('ダウンロード完了','ok');
      } else if (how==='download') {
        toast('ダウンロード開始','ok');
      } else {
        toast('保存しました','ok');
      }

      if(!rightOpen){openRight(true); setTimeout(()=>openRight(false),1200);}
    }catch(e){
      toast(e.message || '保存に失敗しました','err');
    }finally{
      ensureStreamAlive();
    }
  }
  shootBtn.addEventListener('click', doShoot);

  suffixInput.addEventListener('input', ()=>saveState(120));

  resetMarkBtn.addEventListener('click', ()=>{
    [...nums.children].forEach(x=>x.classList.remove('shot'));
    resetAllCounts();
  });

  /* ---------- Drawers ---------- */
  function refreshBackdrop(){
    backdrop.classList.toggle('show', leftOpen || rightOpen);
  }
  function openLeft(open){ leftOpen=!!open; ldrawer.classList.toggle('open', leftOpen); refreshBackdrop(); }
  function openRight(open){ rightOpen=!!open; rdrawer.classList.toggle('open', rightOpen); refreshBackdrop(); }

  lToggle.addEventListener('click',()=>openLeft(!leftOpen));
  rToggle.addEventListener('click',()=>openRight(!rightOpen));
  lClose.addEventListener('click',()=>openLeft(false));
  rClose.addEventListener('click',()=>openRight(false));

  // 外側タップで両方閉じる
  backdrop.addEventListener('click', ()=>{ openLeft(false); openRight(false); });

  // ESCで閉じる（片方でも開いていれば閉じる）
  window.addEventListener('keydown',e=>{
    if(e.key==='Escape'&&(leftOpen||rightOpen)){
      e.preventDefault();
      openLeft(false); openRight(false);
    }
  });

  /* ---------- Preview (pinch zoom / drag) ---------- */
  function getDist(e){if(e.touches.length<2)return 0;const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;return Math.sqrt(dx*dx+dy*dy);}
  img.addEventListener('touchstart',e=>{
    if(e.touches.length===1){
      const now=Date.now();
      if(now-doubleTapTime<300){scale=scale>1?1:2;imgX=0;imgY=0;updateTransform();return;}
      doubleTapTime=now;startX2=e.touches[0].clientX;startY2=e.touches[0].clientY;
    }else if(e.touches.length===2){startDist=getDist(e);lastScale=scale; pinchHint?.remove(); }
  },{passive:true});
  img.addEventListener('touchmove',e=>{
    if(e.touches.length===1&&scale>1){
      const dx=e.touches[0].clientX-startX2,dy=e.touches[0].clientY-startY2; imgX=lastX+dx; imgY=lastY+dy; updateTransform();
    }else if(e.touches.length===2){
      const dist=getDist(e); if(startDist>0){ scale=Math.min(5,Math.max(1,lastScale*dist/startDist)); updateTransform(); }
    }
  },{passive:true});
  img.addEventListener('touchend',()=>{lastX=imgX;lastY=imgY;lastScale=scale;});
  function updateTransform(){ img.style.transform=`translate(calc(-50% + ${imgX}px),calc(-50% + ${imgY}px)) scale(${scale})`; img.style.transition='none'; }

  /* ---------- 音量小で撮影（対応端末のみ・ページにフォーカス必要） ---------- */
  window.addEventListener('keydown',e=>{
    if(e.key==="AudioVolumeDown"||e.key==="VolumeDown"||e.code==="VolumeDown"){ e.preventDefault(); doShoot(); }
  });

  /* ---------- 安定動作：離脱時にカメラ停止 / 復帰で再起動 ---------- */
  function stopStream(){ try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch{} }
  window.addEventListener('pagehide', stopStream);
  document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) ensureStreamAlive(); });
  window.addEventListener('focus', ensureStreamAlive);

  await startCamera();
})();
</script>
